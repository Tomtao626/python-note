---
layout: mypost
title: 01-对象的比较-拷贝
categories: [Python]
---

## 'is'和'=='

- 等于(==)和is是Python中对象比较常用的两种方式。
  - '=='操作符用于比较对象中的值是否相等
  - 'is'操作符用于比较对象的身份标识是否相等，即是否是同一个对象，是否是指向同一个内存地址

### is

- '=='操作符用于比较对象中的值是否相等

```python
a = 1
b = 1
print(a==b) # True
```

- 'is'操作速率优于'=='，因为'is'操作符不能被重载，即比较两个变量的id而已

### ==

- 'is'操作符用于比较对象的身份标识是否相等，即是否是同一个对象，是否是指向同一个内存地址

```python
a = 1
b = 1
print(id(a), '---', id(b)) # 140482668796208 --- 140482668796208
print(a is b) # True
# 在 Python 中，每个对象的身份标识，都能通过函数 id(object) 获得。因此，'is'操作符，相当于比较对象之间的 ID 是否相等
# 首先 Python 会为 1 这个值开辟一块内存，然后变量 a 和 b 同时指向这块内存区域，即 a 和 b 都是指向 1 这个变量，因此 a 和 b 的值相等，id 也相等，a == b和a is b都返回 True。
```

- 执行'=='操作符，相当于是执行a.__eq__(b),而python大部分的数据类型都会去重载__eq__这个函数，内部的处理会复杂一些，比如，对于列表，__eq__函数会去遍历列表中的元素，比较它们的顺序和值是否相等。

### Note

- 需要注意，对于整型数字来说，以上a is b为 True 的结论，只适用于 -5 到 256 范围内的数字

```python
a = 257
b = 257
print(a == b) # True
print(id(a)) # 140482837763632
print(id(b)) # 140482837764016
print(a is b) # False
# 这里把 257 同时赋值给了 a 和 b，可以看到a == b仍然返回 True，因为 a 和 b 指向的值相等。但奇怪的是，a is b返回了 false，并且我们发现，a 和 b 的 ID 不一样了，这是为什么呢？
# 出于对性能优化的考虑，python内部会对-5到256的整数维持一个数组，起到一个缓存的作用，所以每当你试图创建一个-5到256范围内的整型数字时，python都会从这个数组中返回对应的引用，而不是重新开辟一块内存空间。
# 但是，如果整型数字超过了这个范围，比如上述例子中的 257，Python 则会为两个 257 开辟两块内存区域，因此 a 和 b 的 ID 不一样，a is b就会返回 False 了。
```

## 浅拷贝和深拷贝

### 浅拷贝

- 常见的浅拷贝，多是使用数据类型本身的构造器

```python
l1 = [1, 2, 3]
l2 = list(l1)
print(l1, '----', l2) # [1, 2, 3] ---- [1, 2, 3]
print(l1 is l2) # False
print(l1 == l2) # True

s1 = set([1,2,3])
s2 = set(s1)
print(s1, '---', s2) # {1, 2, 3} --- {1, 2, 3}
print(s1 is s2) # False
print(s1 == s2) # True

# l2是l1的浅拷贝，s2是s1的浅拷贝，对于可变的序列，可以通过切片操作符号':'完成浅拷贝
l3 = l1[:]
print(l1, '---', l3) # [1, 2, 3] ---- [1, 2, 3]
print(l1 is l3) # False
print(l1 == l3) # True

# 使用copy.copy() 适用于任意数据类型
import copy
l4 = copy.copy(l1)
print(l1, '---', l4)
print(l1 is l4)
print(l1 == l4)

# 对于元组 使用tuple()或切片操作符':'不会创建一份浅拷贝，相反地，会返回一个指向相同元组的引用
t1 = (1,2,3)
t2 = tuple(t1)
print(t1, '---', t2) # (1, 2, 3) --- (1, 2, 3)
print(t1 is t2) # True
print(t1 == t2) # True
# 元组 (1, 2, 3) 只被创建一次，t1 和 t2 同时指向这个元组
```

- 浅拷贝：重新分配一块内存，创建一个新的对象，里面的元素是原对象中子对象的引用，因此，如果原对象中的元素不可变，那倒无所谓；但如果元素可变，浅拷贝通常会带来一些副作用

```python
l1 = [[1,2], (10,20)]
l2 = list(l1)
l1.append(50)
l1[0].append(3)

print(l1) # [[1,2,3], (10,20), 50]
print(l2) # [[1,2,3], (10,20)]

l1[1]+=(30,40)
print(l1) # [[1,2,3], (10,20,30,40), 50]
print(l2) # [[1,2,3], (10,20), 50]

# 首先初始化了一个列表 l1，里面的元素是一个列表和一个元组；然后对 l1 执行浅拷贝，赋予 l2。因为浅拷贝里的元素是对原对象元素的引用，因此 l2 中的元素和 l1 指向同一个列表和元组对象。
# l1.append(50)，表示对 l1 的列表新增元素 50。这个操作不会对 l2 产生任何影响，因为 l2 和 l1 作为整体是两个不同的对象，并不共享内存地址。操作过后 l2 不变，l1 会发生改变
# l1[0].append(3)，这里表示对 l1 中的第一个列表新增元素 3。因为 l2 是 l1 的浅拷贝，l2 中的第一个元素和 l1 中的第一个元素，共同指向同一个列表，因此 l2 中的第一个列表也会相对应的新增元素 3。操作后 l1 和 l2 都会改变
# l1[1] += (50, 60)，因为元组是不可变的，这里表示对 l1 中的第二个元组拼接，然后重新创建了一个新元组作为 l1 中的第二个元素，而 l2 中没有引用新元组，因此 l2 并不受影响。操作后 l2 不变，l1 发生改变
```

### 深拷贝

- 深拷贝：重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的对象拷贝到新对象中。因此，新对象和原对象没有任何关联
- 使用copy.deepcopy实现深拷贝

```python
import copy
l1 = [[1,2], (10,20)]
l2 = copy.deepcopy(l1)
l1.append(50)
l1[0].append(3)
print(l1) # [[1,2,3], (10,20), 50]
print(l2) # [[1,2], (10,20)]

# 可以看到，无论 l1 如何变化，l2 都不变。因为此时的 l1 和 l2 完全独立，没有任何联系。

# 如果被拷贝对象中存在指向自身的引用，那么程序很容易陷入无限循环：
x = [1]
x.append(x)

print(x) # [1, [...]]

y = copy.deepcopy(x)
print(y) # [1, [...]]

# 列表 x 中有指向自身的引用，因此 x 是一个无限嵌套的列表
# 但是我们发现深度拷贝 x 到 y 后，程序并没有出现 stack overflow 的现象。这是为什么呢？
# 其实，这是因为深度拷贝函数 deepcopy 中会维护一个字典，记录已经拷贝的对象与其 ID。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回，我们来看相对应的源码就能明白：

def deepcopy(x, memo=None, _nil=[]):
    """Deep copy operation on arbitrary Python objects.
      
  See the module's __doc__ string for more info.
  """
  
    if memo is None:
        memo = {}
    d = id(x) # 查询被拷贝对象x的id
  y = memo.get(d, _nil) # 查询字典里是否已经存储了该对象
  if y is not _nil:
      return y # 如果字典里已经存储了将要拷贝的对象，则直接返回
        ...    
```

- 补充知识

```python
import copy
x = [1]
x.append(x)

y = copy.deepcopy(x)

# 以下命令的输出是？
x == y

"""
---------------------------------------------------------------------------
RecursionError                            Traceback (most recent call last)
Cell In [16], line 8
      5 y = copy.deepcopy(x)
      7 # 以下命令的输出是？
----> 8 x == y

RecursionError: maximum recursion depth exceeded in comparison
"""
```

```python
# 应该会出错，因为x是一个无限嵌套的列表，y深拷贝于x，按道理来讲 x == y应该是True的，但进行比较操作符“==”的时候，'=='操作符则会递归地遍历对象的所有值，并逐一比较。而python为了防止栈崩溃，递归的层数是要限定的，不会无休下去，所以到了限定的层数，python解释器会跳出错误。执行了一下代码，也的确是跳出了 RecursionError: maximum recursion depth exceeded in comparison。
# 之前课中做阶乘的例子，如果大于一定的整数，也是会出现递归错误，究其原因也是python的递归层数是有限定的。
def factorial(n):
    return 1 if n <=1 else n*factorial(n-1)
factorial(5000)
RecursionError: maximum recursion depth exceeded in comparison
在sys模块中有个方法可以得到递归的层数:
import sys
sys.getrecursionlimit()
3000
# 当然你也可以重新设定递归的层数：
sys.setrecursionlimit(10000)
```

## Note 

- 比较操作符'=='表示比较对象间的值是否相等，而'is'表示比较对象的标识是否相等，即它们是否指向同一个内存地址。
- 比较操作符'is'效率优于'=='，因为'is'操作符无法被重载，执行'is'操作只是简单的获取对象的 ID，并进行比较；而'=='操作符则会递归地遍历对象的所有值，并逐一比较。
- 浅拷贝中的元素，是原对象中子对象的引用，因此，如果原对象中的元素是可变的，改变其也会影响拷贝后的对象，存在一定的副作用。
- 浅拷贝会创建新对象，其内容非原对象本身的引用，而是原对象内第一层对象的引用。浅拷贝有三种形式:切片操作、工厂函数、copy 模块中的 copy 函数。
- 深拷贝只有一种形式，copy 模块中的 deepcopy()函数。深拷贝和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。因此，它的时间和空间开销要高。
- 深度拷贝则会递归地拷贝原对象中的每一个子对象，因此拷贝后的对象和原对象互不相关。另外，深度拷贝中会维护一个字典，记录已经拷贝的对象及其 ID，来提高效率并防止无限递归的发生。
- 对于非容器类型，如数字、字符，以及其他的“原子”类型，没有拷贝一说，产生的都是原对象的引用。
- 如果元组变量值包含原子类型对象，即使采用了深拷贝，也只能得到浅拷贝。



