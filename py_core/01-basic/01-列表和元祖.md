---
layout: mypost
title: 01-列表和元组
categories: [Python]
---

## 基础

> 可以放置任意数据类型的有序集合

```python
l = [1, "test", 3]
l1 = list(1,2,3)
t = (1, "test", 4)
```

- 列表是动态的，长度大小不固定，可以随意增删改查
- 元组是静态的，长度大小固定，无法增删改

### 列表

- 数据可变

```python
l = [1,2,"test11",6.61]
l[1]="dddd"
print(l)
# [1,"dddd","test11",6.61]
l.append(111)
print(l)
# [1,"dddd","test11",6.61,111]
```

### 元组

- 不可变，需要重新开辟内存，创建新元组
- 元组内的嵌套列表是可变的

```python
t = (1,"222",3.4)
t[0] = "gggg"
#     t[0] = "gggg"
# TypeError: 'tuple' object does not support item assignment
new_t = t + (5,)
# (1,"222",3.4,5)
t2 = (2, "3.333", [1,2,3,4,5])
t2[2][4] = "niubiplus"
t2[2].append(3.1415926)
print(t2)
(2, "3.333", [1,2,3,4,"niubiplus",3.1415926])
```

- 负数索引
  - 从-1开始，表示最后一个元素，依此类推
  - 列表和元组都支持

```python
l = [1,"test",3.1415926,"你好"]
print(l[-2])
# 3.1415926
l[-3] = "gggg"
print(l)
# [1,"gggg",3.1415926,"你好"]

t = (1,2.5,"test222")
print(t[-1])
# "test222"
```

- 切片操作
  - [start:步长:end]
  - 列表和元组都支持
  - 顾头不顾尾

```python
l = [1,2,3,4,5,6]
print(l[2:4])
# [3,4]

t = (1,2,3,4,5,6)
print(t[1:4])
# (2,3,4)
```

- 嵌套操作
  - 任意类型嵌套
  - 元组内的嵌套列表是可变的

```python
l = [[1,2,3], ["test1","gggg","niubi"],(3.1,3.2,3.3)]
print(l)
# [[1,2,3], ["test1","gggg","niubi"],(3.1,3.2,3.3)]

t = ((6,7,8), ["test1","gggg","niubi"],(3.1,3.2,3.3, [66,77,88]))
t[1].append([1,4,7])
print(t)
# ((6, 7, 8), ['test1', 'gggg', 'niubi', [1, 4, 7]], (3.1, 3.2, 3.3, [66, 77, 88]))
```

- 类型转换

```python
l = [1,2,"test"]
t = tuple(l)
print(t)
# (1, 2, 'test')
l1 = list(t)
print(l1)
# [1,2,"test"]
```

- 列表/元组内置操作 
  - count(item) 表示统计列表 / 元组中 item 出现的次数。
  - index(item) 表示返回列表 / 元组中 item 第一次出现的索引。
  - list.reverse() 和 list.sort() 分别表示原地倒转列表和排序（注意，元组没有内置的这两个函数)。
  - reversed() 和 sorted() 同样表示对列表 / 元组进行倒转和排序，reversed() 返回一个倒转后的迭代器（上文例子使用 list() 函数再将其转换为列表）； 
  - sorted() 返回排好序的新列表。

```python
l = [1,"test11",3.1415926]
l.count(1) # 1
l.index(1) # 0
l.reverse() # [3.1415926,"test11",1]
l1 = [1,4,2,6,3,9,0,8]
l.sort() # [0,1,2,3,4,6,8,9]

t = (3, 2, 3, 7, 8, 1)
t.count(3) # 2
t.index(7) # 3
list(reversed(t)) # [1, 8, 7, 3, 2, 3]
sorted(t) # [1, 2, 3, 3, 7, 8]
```

## 存储方式差异

```python
l = [1,2,3]
print(l.__sizeof__()) # 104
t = (1,2,3)
print(t.__sizeof__()) # 48
```

> 不难看出，存储相同的元素，元组占用的空间更少
> + 由于列表是动态的，需要存储指针，从而指向对应的元素，
> + 由于列表可变，所以需要额外存储已经分配的空间大小，方便实时监测列表空间的占用情况，当空间不足时，及时分配额外空间
> + 元组长度大小固定，元素不可变

```python
l = []
l.__sizeof__() # 40 空列表存储空间是40字节
l.append(1)
l.__sizeof__() # 72 加入了一个元素之后，列表为其分配了可以存储4个元素的空间(72-40)/8=4
l.append(2)
l.__sizeof__() # 72 由于之前分配了空间 所以加入了元素2，列表空间不变
l.append(3)
l.__sizeof__() # 72
l.append(4)
l.__sizeof__() # 72
l.append(5)
l.__sizeof__() # 104 加入了元素5 空间长度不足，故又额外分配了可以存储4个元素的空间
# 为了减小每次增加 / 删减操作时空间分配的开销，Python 每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)
```
 
## 性能差异

> 元组性能略优于列表，比较轻量级
> + 对于一些静态变量，如果长时间不被使用，且空间占用较小，python会暂时缓存这部分内存。下次再创建同样空间大小的元组时，不用再向os申请内存，会直接分配之前的缓存空间。

```python
# 初始化一个相同元素的列表和元组所耗费的时间，元组比列表快5倍
import timeit

print(timeit.timeit('l=[1,2,3,4,5,6]')) # 0.046208755999941786
print(timeit.timeit('l=(1,2,3,4,5,6)')) # 0.009252004000245506

# 但如果是索引操作的话，两者的速度差别非常小，几乎可以忽略不计。
print(timeit.timeit('l=[1,2,3,4,5,6], y=l[4]')) # 0.0075512359999265755
print(timeit.timeit('l=(1,2,3,4,5,6), y=l[4]')) # 0.006128987000010966
```

> 如果你想要增加、删减或者改变元素，那么列表显然更优。原因你现在肯定知道了，那就是对于元组，你必须得通过新建一个元组来完成。

## 使用场景

- 存储数据是动态可变化的，推荐用列表
- 存储数据是静态不可变化的，推荐用元组